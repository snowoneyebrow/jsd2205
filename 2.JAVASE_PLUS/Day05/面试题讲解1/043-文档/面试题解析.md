# 面试题解析

## 1. == 与 equals() 的区别

> 关于“对比”类型的面试题，建议回答时包括：
>
> - 多个对比项有什么相同 / 相似之处
> - 多个对比项的区别
> - 在应用中应该如何选取（重要）
> - 可能的话，加入一些扩展（对相关知识点的理解）

【相同之处】

都是对比2个数据是否相同；

【不同之处】

- == 符号可以对比所有数据，而 equals() 只能被对象调用；
- == 符号对比变量的值是否相同，所以，基本类型的变量只要字面值相同即返回true，引用类型的变量仅当引用地址相同时才返回true；
- equals()方法是Object定义的，默认使用 == 实现对比，所以，当该方法没有被重写时，执行效果与 == 相同，如果被重写，则取决于重写的代码。
  - 以String类为例，在执行 equals() 将逐一对比字符串中的每个字符，所以，只要2个String对象的字符完全相同，2个String对象使用 equals() 对比将返回true；

【补充说明】

由于Java会在编译期处理常量，并且，常量池中的每个常量都是唯一的，所以，当使用字符串常量直接对变量赋值，或使用 [-128, 127] 区间值对Byte / Short / Integer / Long类型的对象赋值时，使用 == 对比的结果也是true。

【实际应用原则】

在实际编写代码时，对于基本数据类型的变量，必须使用 == 进行对比，因为基本数据类型的变量不可以调用 equals() 方法；对于引用数据类型的变量，推荐使用 equals() 进行对比，并且，在有必要的情况下，重写 equals() 方法，使之返回结果的规则符合当前编写代码的需求，在重写时，至少保证同一个对象的对比结果为true（即：如果 == 对比为true时，则 equals() 对比返回true）。

## 2. 什么是hashCode

【理解】

hashCode()是Object定义的方法，它将返回一个整型值，它并不代表对象在内存中的地址，它存在的价值是为Hash容器处理数据时提供支持，Hash容器可以根据hashCode定位需要使用的对象，也可以根据hashCode来排除2个不相同的对象，即：hashCode不同，则视为2个对象不同；

【应用】

在重写hashCode()时，应该遵循Java SE的官方指导：

- 如果2个对象使用equals()对比的结果为true，则这2个对象的hashCode()返回的结果应该相同；
- 如果2个对象使用equals()对比的结果为false，则这2个对象的hashCode()返回的结果应该不同；
- 通常，你不必关心如何重写equals()方法和hashCode()方法，而是使用IDE生成，例如Eclipse、IntelliJ IDEA，它们生成的方法是符合以上指导意见的。

## 3. String、StringBuffer和StringBuilder的区别

【相同之处】

- 都是用于处理字符串数据的类
- 都是管理内部的一个char[]实现的
- 实现的接口大致相同，特别是CharSequence接口
- 有许多相同的API，例如replace()、indexOf()等

【不同之处】

- String的字符串操作效率低下，是因为它的“不可变”特性决定的
- StringBuffer和StringBuiler会保证管理的char[]的长度始终高于实际存入的字符长度，在处理字符串操作时，效率远高于String
- StringBuffer是线程安全的，而StringBuilder不是

【实际使用原则】

尽管StringBuffer和StringBuilder在处理字符串时的效率远高于String，但并不是每个String都需要频繁的改变，相比之下，使用String的语法更加简洁、直观，实际占用的存储空间更小，所以，当字符串不需要频繁的改变时，优先使用String。如果字符串需要频繁改变，原则上来说，仅当单线程运行时，或已经采取措施保障线程安全时，优先使用StringBuilder，因为它的执行效率高于StringBuffer，事实上，尽管StringBuilder的执行效率比StringBuffer高，但差距并不大，为了避免后续调整带来的安全隐患，当字符串可能频繁改变时，一般使用StringBuffer。

## 4. ArrayList与LinkedList的区别

【相同之处】

- 都是List接口的实现类
  - 都是序列的，可存储相同元素
  - 绝大部分情况下，不关心特有方法
- 都是线程不安全的

【不同之处】

- ArrayList的底层实现是基于数组的，所以，查询效率高，但修改效率偏低
- LinkedList的底层实现是基于双向链表的，所以，查询效率偏低，但修改效率高，另外，其内部本质上管理的是多个节点，每个节点需要记录指向前一个节点和后一个节点的引用，占用的存储空间更多

【实际使用原则】

实际使用原则：在使用简单的字符串作为集合元素时，在10万级别的元素数量时，ArrayList和LinkedList的性能差异并不明显（在绝大部分情况下，使用List时的元素数量都不超过100个，尽管元素数据更加复杂），并且，不可以单纯的只读不写，或只写不读，同时，基于ArrayList占用的存储空间更少，一般使用ArrayList即可，仅当需要极致的追求性能时，再根据读写频率来区分使用，但是，当需要考虑线程安全问题时，则使用CopyOnWriteArrayList。
